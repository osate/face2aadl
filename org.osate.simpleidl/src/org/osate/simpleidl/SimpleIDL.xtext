/*******************************************************************************
 * FACE Data Model to AADL Translator
 * 
 * Copyright 2018 Carnegie Mellon University. All Rights Reserved.
 * 
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON
 * AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
 * AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY,
 * EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY
 * WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 * 
 * Released under an Eclipse Public License - v1.0-style license, please see license.txt or contact
 * permission@sei.cmu.edu for full terms.
 * 
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.
 * Please see Copyright notice for non-US Government use and distribution.
 * 
 * DM18-0762
 *******************************************************************************/
grammar org.osate.simpleidl.SimpleIDL with org.eclipse.xtext.common.Terminals hidden(WS, ML_COMMENT, SL_COMMENT,
PREPROCESSOR)

generate simpleIDL "http://www.osate.org/simpleidl/SimpleIDL"

/*
 * This is a subset of IDL 4.2. It is intended to be used to parse IDL files generated from the FACE Conformance Test
 * Suite 3.0. Portions of IDL which are not generated by the FACE CTS are not included in this subset.
 * 
 * In one case, FACE's version of IDL in the FACE standard disagrees with the IDL standard. In FACE, a union has an
 * opening curly between the union's name and the "switch" keyword. It also has a corresponding closing curly and
 * semicolon at the end of the union. These are not in the IDL standard. This subset follows the FACE standard for
 * unions and deviates from the IDL standard.
 * 
 * The comments on each grammar rule in this file contain the relevant syntax definitions from the IDL standard's
 * Annex A: Consolidated IDL Grammar.
 */

/*
 * (1) <specification> ::= <definition>+
 */
Specification:
	definitions+=Definition+
;

/*
 * (2) <definition> ::= <module_dcl> ";"
 *                  | <const_dcl> ";"
 *                  | <type_dcl> ";"
 * (3) <module_dcl> ::= "module" <identifier> "{" <definition>+ "}"
 * (20) <type_dcl> ::= <constr_type_dcl>
 *                 | <native_dcl>
 *                 | <typedef_dcl>
 * (44) <constr_type_dcl> ::= <struct_dcl>
 *                        | <union_dcl>
 *                        | <enum_dcl>
 * (45) <struct_dcl> ::= <struct_def>
 *                   | <struct_forward_dcl>
 * (46) <struct_def> ::= "struct" <identifier> "{" <member>+ "}"
 * (48) <struct_forward_dcl> ::= "struct" <identifier>
 * (49) <union_dcl> ::= <union_def>
 *                  | <union_forward_dcl>
 * (50) <union_def> ::= "union" <identifier> "switch" "(" <switch_type_spec> ")"
 *                      "{" <switch_body> "}"
 * (51) <switch_type_spec> ::= <integer_type>
 *                         | <char_type>
 *                         | <boolean_type>
 *                         | <scoped_name>
 * (52) <switch_body> ::= <case>+
 * (57) <enum_dcl> ::= "enum" <identifier>
 *                     "{" <enumerator> { "," <enumerator> } * "}"
 * (58) <enumerator> ::= <identifier>
 * (59) <array_declarator> ::= <identifier> <fixed_array_size>+
 * (60) <fixed_array_size> ::= "[" <positive_int_const> "]"
 * (62) <simple_declarator> ::= <identifier>
 * (63) <typedef_dcl> ::= "typedef" <type_declarator>
 * (64) <type_declarator> ::= { <simple_type_spec>
 *                            | <template_type_spec>
 *                            | <constr_type_dcl>
 *                            } <any_declarators>
 * (65) <any_declarators> ::= <any_declarator> { "," <any_declarator> }*
 * (66) <any_declarator> ::= <simple_declarator>
 *                       | <array_declarator>
 */
Definition:
	{Module} 'module' name=ID '{' definitions+=Definition+ '}' ';' |
	{Struct} 'struct' name=ID '{' members+=Member+ '}' ';' |
	{StructForward} 'struct' struct=[Struct] ';' |
	//The syntax for union follows the FACE standard, not the IDL standard.
	{Union} 'union' name=ID '{' 'switch' '(' 'unsigned' 'short' ')' '{' cases+=Case+ '}' ';' '}' ';' |
	{Enum} 'enum' name=ID '{' literals+=ID (',' literals+=ID)* '}' ';' |
	{Typedef} 'typedef' type=Type name=ID ';' |
	{ArrayType} 'typedef' type=[Definition|ScopedName] name=ID '[' size=INT ']' ';'
;

/*
 * (21) <type_spec> ::= <simple_type_spec>
 * (22) <simple_type_spec> ::= <base_type_spec>
 *                         | <scoped_name>
 * (47) <member> ::= <type_spec> <declarators> ";"
 * (62) <simple_declarator> ::= <identifier>
 * (67) <declarators> ::= <declarator> { "," <declarator> }*
 * (68) <declarator> ::= <simple_declarator>
 */
Member:
	type=[Definition|ScopedName] name=ID ';'
;

/*
 * (21) <type_spec> ::= <simple_type_spec>
 * (22) <simple_type_spec> ::= <base_type_spec>
 *                         | <scoped_name>
 * (53) <case> ::= <case_label>+ <element_spec> ";"
 * (54) <case_label> ::= "case" <const_expr> ":"
 *                   | "default" ":"
 * (55) <element_spec> ::= <type_spec> <declarator>
 * (62) <simple_declarator> ::= <identifier>
 * (68) <declarator> ::= <simple_declarator>
 */
Case:
	('case' labels+=INT ':')+ type=[Definition|ScopedName] name=ID ';'
;

/*
 * (21) <type_spec> ::= <simple_type_spec>
 * (22) <simple_type_spec> ::= <base_type_spec>
 *                         | <scoped_name>
 * (23) <base_type_spec> ::= <integer_type>
 *                       | <floating_pt_type>
 *                       | <char_type>
 *                       | <wide_char_type>
 *                       | <boolean_type>
 *                       | <octet_type>
 * (24) <floating_pt_type> ::= "float"
 *                         | "double"
 *                         | "long" "double"
 * (25) <integer_type> ::= <signed_int>
 *                     | <unsigned_int>
 * (26) <signed_int> ::= <signed_short_int>
 *                   | <signed_long_int>
 *                   | <signed_longlong_int>
 * (27) <signed_short_int> ::= "short"
 * (28) <signed_long_int> ::= "long"
 * (29) <signed_longlong_int> ::= "long" "long"
 * (30) <unsigned_int> ::= <unsigned_short_int>
 *                     | <unsigned_long_int>
 *                     | <unsigned_longlong_int>
 * (31) <unsigned_short_int> ::= "unsigned" "short"
 * (32) <unsigned_long_int> ::= "unsigned" "long"
 * (33) <unsigned_longlong_int> ::= "unsigned" "long" "long"
 * (34) <char_type> ::= "char"
 * (35) <wide_char_type> ::= "wchar"
 * (36) <boolean_type> ::= "boolean"
 * (37) <octet_type> ::= "octet"
 * (38) <template_type_spec> ::= <sequence_type>
 *                           | <string_type>
 *                           | <wide_string_type>
 *                           | <fixed_pt_type>
 * (39) <sequence_type> ::= "sequence" "<" <type_spec> "," <positive_int_const> ">"
 *                      | "sequence" "<" <type_spec> ">"
 * (40) <string_type> ::= "string" "<" <positive_int_const> ">"
 *                    | "string"
 * (41) <wide_string_type> ::= "wstring" "<" <positive_int_const> ">"
 *                         | "wstring"
 * (42) <fixed_pt_type> ::= "fixed" "<" <positive_int_const> "," <positive_int_const> ">"
 * (64) <type_declarator> ::= { <simple_type_spec>
 *                            | <template_type_spec>
 *                            | <constr_type_dcl>
 *                            } <any_declarators>
 */
Type:
	{SignedShortInt} 'short' |
	{SignedLongInt} 'long' |
	{SignedLongLongInt} 'long' 'long' |
	{UnsignedShortInt} 'unsigned' 'short' |
	{UnsignedLongInt} 'unsigned' 'long' |
	{UnsignedLongLongInt} 'unsigned' 'long' 'long' |
	{FloatType} 'float' |
	{DoubleType} 'double' |
	{LongDoubleType} 'long' 'double' |
	{CharType} 'char' |
	{WideCharType} 'wchar' |
	{BooleanType} 'boolean' |
	{OctetType} 'octet' |
	{ReferencedType} type=[Definition|ScopedName] |
	{BoundedSequence} 'sequence' '<' type=[Definition|ScopedName] ',' size=INT '>' |
	{UnboundedSequence} 'sequence' '<' type=[Definition|ScopedName] '>' |
	{BoundedString} 'string' '<' size=INT '>' |
	{UnboundedString} 'string' |
	{BoundedWideString} 'wstring' '<' size=INT '>' |
	{UnboundedWideString} 'wstring' |
	{FixedPtType} 'fixed' '<' totalDigits=INT ',' fractionalDigits=INT '>'
;

/*
 * (4) <scoped_name> ::= <identifier>
 *                   | "::" <identifier>
 *                   | <scoped_name> "::" <identifier>
 */
ScopedName:
	'::'? (ID '::')* ID
;

@Override 
terminal ID:
	('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

terminal PREPROCESSOR:
	('#define' | '#endif' | '#ifndef' | '#include') !('\n'|'\r')* ('\r'? '\n')?
;